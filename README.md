# 1軸ジャイロ・2軸加速度センサによる姿勢推定システム (EKF)

## 1. 概要

本システムは、低価格なMEMSセンサに特有の課題を解決し、高精度な傾き（Roll角）を推定するアルゴリズムです。

**拡張カルマンフィルタ（Extended Kalman Filter: EKF）** を用いて、以下のセンサ特性を相互補完します。

* **ジャイロセンサ（角速度計）**: 短期的には正確だが、積分すると**バイアス（オフセット）により無限にドリフト**する。  
* **加速度センサ（重力計）**: 長期的には重力方向を指すが、振動などの**高周波ノイズ**に弱い。

本設計では、**「クォータニオン（四元数）」**を用いることで、ジンバルロックを回避し、数学的に安定した計算を実現しています。

---

## 2. システムモデル

### 2.1 座標系と定義

* **世界座標系**: $Z$軸が鉛直上向き、重力ベクトル $g = [0, 0, 1]^T$（単位ベクトルとして正規化）。  
* **機体座標系**: センサが固定されている座標系。  
* **対象**: $X$軸周りの回転（**Roll角**）。  
  * ※ $Z$軸（Yaw）回転は重力方向が変化しないため、加速度センサのみでは補正不可能です（可観測性なし）。本システムでは重力変化が観測可能なRoll回転を対象とします。

### 2.2 状態ベクトル ($\mathbf{x}$)

システムの状態を以下の5次元ベクトルで定義します。

$$\mathbf{x} = \begin{bmatrix} q_w & q_x & q_y & q_z & b \end{bmatrix}^T$$

* $q_w, q_x, q_y, q_z$: 姿勢を表すクォータニオン（ノルムは常に1）。  
* $b$: ジャイロセンサのバイアス（誤差成分）。

---

## 3. アルゴリズム詳細（拡張カルマンフィルタ）

EKFは「予測（Predict）」と「更新（Update）」の2ステップを繰り返します。

### 3.1 予測ステップ（Time Update）

ジャイロセンサの値を積分し、次の時刻の姿勢を予測します。同時にバイアス誤差の影響も考慮します。

**物理モデル:**

真の角速度 $\omega$ は、計測値 $\omega_{mes}$ からバイアス $b$ を引いたものです。

$$\omega = \omega_{mes} - b$$  
**クォータニオンの微分方程式:**

$$\dot{\mathbf{q}} = \frac{1}{2} \mathbf{q} \otimes \Omega(\omega)$$  
ここで $\Omega$ は角速度ベクトル $[0, \omega, 0, 0]$ （X軸回転のみ）をクォータニオン形式にしたものです。

**状態遷移（離散化）:**

$$\mathbf{x}_{k+1} = f(\mathbf{x}_k, u_k)$$  
実装では、微小時間 $\Delta t$ における1次のオイラー積分を用いています。

**ヤコビ行列 ($F$):**

非線形モデルを線形化するための行列です（$\frac{\partial f}{\partial \mathbf{x}}$）。

$$F = \begin{bmatrix} \quad \text{Quaternion Kinematics} \quad & \frac{\partial \mathbf{q}}{\partial b} \\ \mathbf{0}_{1 \times 4} & 1 \end{bmatrix}$$  
バイアスがクォータニオンに与える影響（右上の項）を考慮することで、フィルタは**「姿勢のズレはバイアスのせいではないか？」**と推論できるようになります。

### 3.2 更新ステップ（Measurement Update）

加速度センサの観測値と、現在の推定姿勢から予測される重力方向を比較し、補正をかけます。

**観測モデル:**

現在の姿勢 $\mathbf{q}$ において、世界座標系の重力 $g=[0,0,1]$ が機体座標系でどう見えるかを計算します。

回転行列 $R(\mathbf{q})$ の逆行列（転置）を重力ベクトルに掛けたものが予測値 $h(\mathbf{x})$ です。

$$h(\mathbf{x}) = R(\mathbf{q})^T \cdot \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} = \begin{bmatrix} 2(q_x q_z - q_w q_y) \\ 2(q_y q_z + q_w q_x) \\ 1 - 2(q_x^2 + q_y^2) \end{bmatrix}$$  
今回はRoll回転（X軸）に伴う $Y, Z$ 軸の加速度変化を使用するため、上記ベクトルの第2、第3成分を使用します。

**ヤコビ行列 ($H$):**

観測モデルの偏微分（$\frac{\partial h}{\partial \mathbf{x}}$）です。

予測値と実測値のズレ（残差）を、クォータニオンのどの成分を修正することで解消すべきかを決定します。

---

## 4. チューニングガイド（実装の秘訣）

本システムが実用レベルで動作するためには、以下の3つのパラメータ行列（共分散行列）の設定が極めて重要です。

### ① 初期誤差共分散 ($P$)

「初期状態（特にバイアス）をどれくらい疑っているか」を設定します。

* **設定**: diag([1e-2, ..., 1.0])  
* **意図**: バイアス成分（最後の項）を 1.0 と極端に大きく設定します。これにより、起動直後の数ステップでフィルタが猛烈にバイアスを修正しに行き、**爆速の立ち上がり**を実現します。

### ② プロセスノイズ ($Q$)

「モデルの予測をどれくらい信用しないか（システムがどれくらい揺らぐか）」を設定します。

* **設定**: diag([..., 1e-10]) (バイアス項)  
* **意図**: バイアス項を極小にします。**「バイアスは物理的に急激に変動するものではない」**という制約を与えることで、推定後のバイアス値のふらつきを抑え、安定させます。

### ③ 観測ノイズ ($R$)

「センサの値をどれくらい信用しないか（ノイズが多いか）」を設定します。

* **設定**: eye(2) * 0.5  
* **意図**: 加速度センサのノイズレベルより少し大きめに設定します。これにより、突発的な振動（スパイクノイズ）を無視し、**滑らかな推定結果**を得ます。

---

## 5. Python 実装コード

以下は、最終的に調整された「収束速度」と「安定性」を両立したコードです。

### ekf_filter.py

```python
import numpy as np

class QuaternionEKF:  
    def __init__(self, dt, q_init=[1.0, 0.0, 0.0, 0.0], bias_init=0.0):  
        self.dt = dt  
        # 状態ベクトル [qw, qx, qy, qz, bias]  
        self.x = np.array([*q_init, bias_init], dtype=float)  
          
        # P: 初期誤差共分散  
        # バイアス(index 4)の初期値を大きくし、開始直後の学習速度を最大化  
        self.P = np.diag([1e-2, 1e-2, 1e-2, 1e-2, 1.0])  
          
        # Q: プロセスノイズ共分散  
        # バイアスの変動(index 4)を極小にし、推定後のふらつきを抑制  
        self.Q = np.diag([1e-7, 1e-7, 1e-7, 1e-7, 1e-10])  
          
        # R: 観測ノイズ共分散  
        # 加速度センサのノイズを許容し、滑らかさを確保  
        self.R = np.eye(2) * 0.5

    def predict(self, gyro_x):  
        qw, qx, qy, qz, b = self.x  
          
        # 1. バイアス補正  
        omega = gyro_x - b  
          
        # 2. クォータニオンの時間発展 (X軸回転)  
        # dq/dt = 0.5 * q * [0, w, 0, 0]  
        half_omega_dt = 0.5 * omega * self.dt  
        new_qw = qw - qx * half_omega_dt  
        new_qx = qx + qw * half_omega_dt  
        new_qy = qy + qz * half_omega_dt # 他軸への連成項  
        new_qz = qz - qy * half_omega_dt # 他軸への連成項  
          
        self.x[:4] = np.array([new_qw, new_qx, new_qy, new_qz])  
        self.x[:4] /= np.linalg.norm(self.x[:4]) # 正規化(必須)  
          
        # 3. ヤコビ行列 F の計算  
        F = np.eye(5)  
        # バイアス偏微分項 (d(dq)/db)  
        F[0, 4] =  0.5 * qx * self.dt  
        F[1, 4] = -0.5 * qw * self.dt  
        F[2, 4] = -0.5 * qz * self.dt  
        F[3, 4] =  0.5 * qy * self.dt  
          
        # 4. 共分散の更新  
        self.P = F @ self.P @ F.T + self.Q

    def update(self, acc_y, acc_z):  
        qw, qx, qy, qz, _ = self.x  
          
        # 1. 観測予測 (重力ベクトルの回転)  
        # Roll回転において観測可能な Y, Z 成分  
        hy = 2.0 * (qy * qz + qw * qx)  
        hz = 1.0 - 2.0 * (qx * qx + qy * qy)  
        z_pred = np.array([hy, hz])  
          
        # 2. ヤコビ行列 H の計算  
        H = np.zeros((2, 5))  
        # d(hy)/dq  
        H[0, 0] = 2 * qx; H[0, 1] = 2 * qw; H[0, 2] = 2 * qz; H[0, 3] = 2 * qy  
        # d(hz)/dq  
        H[1, 0] = 0;      H[1, 1] = -4*qx;  H[1, 2] = -4*qy;  H[1, 3] = 0  
          
        # 3. カルマンゲイン K の計算  
        S = H @ self.P @ H.T + self.R  
        K = self.P @ H.T @ np.linalg.inv(S)  
          
        # 4. 状態の更新  
        acc = np.array([acc_y, acc_z])  
        acc_norm = np.linalg.norm(acc)  
        if acc_norm > 1e-6: # ゼロ除算防止  
            z_meas = acc / acc_norm  
            y_residual = z_meas - z_pred  
              
            self.x = self.x + K @ y_residual  
            self.x[:4] /= np.linalg.norm(self.x[:4]) # 再正規化  
            self.P = (np.eye(5) - K @ H) @ self.P

    def get_euler_roll(self):  
        """現在のRoll角(度)を取得"""  
        qw, qx, qy, qz, _ = self.x  
        roll = np.arctan2(2*(qw*qx + qy*qz), 1 - 2*(qx**2 + qy**2))  
        return np.degrees(roll)
```

---

## 6. まとめ

このシステムは、単純なフィルタリング（相補フィルタなど）とは異なり、**「なぜズレているのか（姿勢が間違っているのか、バイアスが間違っているのか）」を確率的に判断**します。

その結果、以下の挙動を実現します。

1. **静止時**: 加速度センサを信頼し、ジャイロのバイアスを自動学習する。  
2. **回転時**: ジャイロセンサを信頼し、遅れのない追従を行う。  
3. **長期的**: バイアスが除去されているため、積分ドリフトが発生しない。

実機に組み込む際は、dt（サンプリング周期）を正確に管理することをお勧めします。

